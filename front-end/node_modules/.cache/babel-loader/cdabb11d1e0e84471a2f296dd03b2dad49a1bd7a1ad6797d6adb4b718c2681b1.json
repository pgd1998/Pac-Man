{"ast":null,"code":"var _jsxFileName = \"/Users/poorvithgowda/Desktop/Pac-Man/front-end/src/components/PacMan.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport './PacMan.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CELL_SIZE = 40;\nconst PacMan = ({\n  maze,\n  setMaze\n}) => {\n  _s();\n  const [position, setPosition] = useState({\n    x: 1,\n    y: 1\n  });\n  const [direction, setDirection] = useState(null);\n  const handleKeyDown = e => {\n    switch (e.key) {\n      case 'ArrowUp':\n        setDirection('up');\n        break;\n      case 'ArrowDown':\n        setDirection('down');\n        break;\n      case 'ArrowLeft':\n        setDirection('left');\n        break;\n      case 'ArrowRight':\n        setDirection('right');\n        break;\n      default:\n        break;\n    }\n  };\n\n  // In the switch here max(0) and min(maze.length) is used to overflow from the maze\n  const movePacMan = () => {\n    let newX = position.x;\n    let newY = position.y;\n    switch (direction) {\n      case 'up':\n        newY = Math.max(0, position.y - 1);\n        break;\n      case 'down':\n        newY = Math.min(maze.length - 1, position.y + 1);\n        break;\n      case 'left':\n        newX = Math.max(0, position.x - 1);\n        break;\n      case 'right':\n        newX = Math.min(maze[0].length - 1, position.x + 1);\n        break;\n      default:\n        break;\n    }\n    // Checks if the new position is not a wall\n    // The 2 serves as a marker to indicate that a pellet was present in that cell \n    // but has now been consumed.This helps in keeping track of which pellets have been eaten \n    // and which are still available and also to avoid re-consumption.\n    if (maze[newY][newX] != 1) {\n      setPosition({\n        x: newX,\n        y: newY\n      });\n      if (maze[newY][newX] === 0) {\n        const newMaze = maze.map((row, rowIndex) => row.map((cell, cellIndex) => {\n          if (rowIndex === newY && cellIndex === newX) {\n            return 2;\n          }\n          return cell;\n        }));\n        setMaze(newMaze);\n      }\n    }\n  };\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    // reduce the value from 300 to 100 to increase the PacMan's speed \n    const interval = setInterval(movePacMan, 250);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      clearInterval(interval);\n    };\n  }, [direction, position]);\n  return (\n    /*#__PURE__*/\n    // top and left is enough to position pacman correctly\n    // within the gameboard and style is done here \n    // so that every time pacman moves and re-renders the pacman (dot)\n    // will maintain the same size to fit inside the cell \n    _jsxDEV(\"div\", {\n      className: \"pacman\",\n      style: {\n        top: `${position.y * CELL_SIZE}px`,\n        left: `${position.x * CELL_SIZE}px`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 9\n    }, this)\n  );\n};\n_s(PacMan, \"MBjbyBqYWBTJ+Gemzy1iH7jUXXU=\");\n_c = PacMan;\nexport default PacMan;\nvar _c;\n$RefreshReg$(_c, \"PacMan\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","CELL_SIZE","PacMan","maze","setMaze","_s","position","setPosition","x","y","direction","setDirection","handleKeyDown","e","key","movePacMan","newX","newY","Math","max","min","length","newMaze","map","row","rowIndex","cell","cellIndex","window","addEventListener","interval","setInterval","removeEventListener","clearInterval","className","style","top","left","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/poorvithgowda/Desktop/Pac-Man/front-end/src/components/PacMan.jsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport './PacMan.css';\n\nconst CELL_SIZE = 40;\n\nconst PacMan = ({maze,setMaze}) => {\n    const [position, setPosition] = useState({ x: 1, y: 1 });\n    const [direction, setDirection] = useState(null);\n\n    const handleKeyDown = (e) => {\n        switch (e.key) {\n            case 'ArrowUp':\n                setDirection('up')\n                break;\n            case 'ArrowDown':\n                setDirection('down')\n                break;\n            case 'ArrowLeft':\n                setDirection('left')\n                break;\n            case 'ArrowRight':\n                setDirection('right')\n                break;\n            default:\n                break;\n        }\n    }\n\n    // In the switch here max(0) and min(maze.length) is used to overflow from the maze\n    const movePacMan=() => {\n        let newX = position.x;\n        let newY = position.y;\n\n        switch (direction) {\n            case 'up':\n                newY = Math.max(0, position.y - 1);\n                break;\n            case 'down':\n                newY = Math.min(maze.length - 1, position.y + 1);\n                break;\n            case 'left':\n                newX = Math.max(0, position.x - 1);\n                break;\n            case 'right':\n                newX = Math.min(maze[0].length - 1, position.x + 1);\n                break;\n            default:\n                break;\n        }\n        // Checks if the new position is not a wall\n        // The 2 serves as a marker to indicate that a pellet was present in that cell \n        // but has now been consumed.This helps in keeping track of which pellets have been eaten \n        // and which are still available and also to avoid re-consumption.\n        if (maze[newY][newX] != 1) {\n            setPosition({ x: newX, y: newY });\n            if (maze[newY][newX] === 0) {\n                const newMaze = maze.map((row, rowIndex) =>\n                    row.map((cell, cellIndex) => {\n                        if (rowIndex === newY && cellIndex === newX) {\n                            return 2;\n                        }\n                        return cell;\n                    })\n                )\n                setMaze(newMaze);\n            }\n        }\n    }\n\n    useEffect(() => {\n        window.addEventListener('keydown', handleKeyDown);\n        // reduce the value from 300 to 100 to increase the PacMan's speed \n        const interval = setInterval(movePacMan, 250);\n        return () => {\n            window.removeEventListener('keydown', handleKeyDown);\n            clearInterval(interval)\n        };\n    }, [direction, position]);\n\n    return (\n        // top and left is enough to position pacman correctly\n        // within the gameboard and style is done here \n        // so that every time pacman moves and re-renders the pacman (dot)\n        // will maintain the same size to fit inside the cell \n        <div \n            className=\"pacman\"\n            style={{\n                top: `${position.y * CELL_SIZE}px`,\n                left:`${position.x * CELL_SIZE}px`\n        }}></div>\n    )\n}\n\nexport default PacMan;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}